
- [ ] Надо для каждого байта проверить, был ли он уже установлен (перекрытие).

- [ ] Надо уметь определять "дырки" (гэпы, gaps, зазор, разрыв) - для справки.

- [ ] Надо уметь мержить HEX-ы. При этом проверяем, переписываем ли мы какие-то ячейки, 
      и если не установлена опция mergeOverwrite - выдавать ошибку.

- [X] Надо уметь сортировать HEX-ы по адресам. Но перед этим надо проверить, нет ли перекрытий. 
      Если перекрытия есть, то это ошибка.

- [X] Проверка типа адресации - в одном HEX-е не должно быть нескольких записей с базовым 
      адресом разного типа, но  может быть несколько записей одного типа.

- [ ] Операции над HEX-ами: `--merge`, `--merge-overwrite` - слияние и слияние с перекрытием.
      Тип адресации LBA/SBA должен совпадать для HEX-ов, или отсутствовать в одном из них 
      (но вообще это не правильно, когда отсутствует запись с базовым адресом).

- [ ] Конвертация двоичного файла в HEX. Нужно задавать адрес начала, и, опционально, стартовый адрес.

- [ ] Нужно уметь читать простые хексы вида (dump'ы):

      `XXXXXXXX: XX XX XX XX`

      и делать из них нормальные. Может отсутствовать адресная часть, и тогда надо задавать 
      адрес из командной строки - команда `--convert-dump`.
      
      Также из командной строки задаём тип адресации: LBA/SBA - `--address-mode`.

      Адресная часть может присутствовать только в части строк, при этом строка адресом может 
      не содержать байты дампа. LBA режим - адрес одним 32х-битным числом, SBA - пара 16ти-разрядных чисел,
      разделенных двоеточием. Адрес всегда должен заканчиваться на двоеточие, даже если в строке с ним
      нет байт дампа.

      Адрес также может быть разделён пробелами побайтно. Этим обеспечивается универсальность парсера.
      Базовый адрес имеет тип uint64_t.
      Базовый адрес по умолчанию: FFFFFFFFFFFFFFFF. 
      Смещение внутри сегмента - тоже uint64_t с дефолтным значением FFFFFFFFFFFFFFFF.
      Встречаем первое двоеточие: устанавливаем смещение внутри сегмента. Также запоминам разрядность,
      даже если ведущие символы - все нули. 
      Встречаем второе двоеточие - перекидываем смещение в сегментный адрес.
      Если сегментный адрес или смещение больше 16ти разрядов - это ошибка.
      Если сегментный адрес по итогам разбора строки не был модифицирован - значит, это не сегментный
      адрес, а линейный.

- [ ] Сделать разбор [Packet Diagram](https://mermaid.js.org/syntax/packet.html)
      Пример строки диаграммы:

      `0-15: "Source Port"`

      вместо первого и второго числа может быть: 
      1. тип (int/uint/8/16/32/64 или char) - identifier - тогда без диапазона;
      2. тип с размером в квадратных скобках, например: `uint16[10]`;
      3. тип с размером в квадратных скобках, при этом размер может быть задан выражением;
      4. выражение в скобках (). В выражениях может использоваться переменная - литерал, заключенный 
         в двойные кавычки. Переменные должны быть заданы ранее (из командной строки), как имена полей, 
         или заданы извне.
         Унариный плюс и минус надо поддерживать?
      5. если значение переменной не задано, то она должна быть одной из ранее заданных переменных 
         (описаний полей), иначе - ошибка.

- [ ] `packet` - надо задать для диаграммы тип - bit/byte diagram. Для bit правила проще - нет квадратных 
      скобок (индекса), что-то ещё, возможно.

- [ ] `packet` - уметь задавать ширину - view-width? Ширина тут - это сколько байт отображать на одной строке
      диаграммы.

- [ ] `packet` - коментарий начинается с символа '#'

- [ ] `packet` - директивы задания опций делаем как коментарий вида `#!` строго в начале строки (после 
       опциональных пробелов)

- [ ] Заметка. Включить 16ти-ричное отображение переменных в отладчике: `-exec set output-radix 16`