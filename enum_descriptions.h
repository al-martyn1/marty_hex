/*! \file
    \brief Autogenerated enumerations description maps (Umba Enum Gen)
 */

#pragma once


#include "marty_cpp/marty_enum.h"
#include "marty_cpp/marty_flag_ops.h"
#include "marty_cpp/marty_flags.h"

#include <exception>
#include <map>
#include <stdexcept>
#include <string>
#include <unordered_map>



namespace marty{
namespace hex{

inline std::map<HexRecordType, std::string> makeHexRecordTypeDescriptionMap()
{
std::map<HexRecordType, std::string> m =
{
{ HexRecordType::invalid                 , "" },
{ HexRecordType::unknown                 , "" },
{ HexRecordType::data                    , "Data" },
{ HexRecordType::eof                     , "End Of File. Must occur exactly once per file in the last record of the file." },
{ HexRecordType::extendedSegmentAddress  , "Extended Segment Address" },
{ HexRecordType::startSegmentAddress     , "Start Segment Address" },
{ HexRecordType::extendedLinearAddress   , "Extended Linear Address" },
{ HexRecordType::startLinearAddress      , "Start Linear Address" }
};
return m;
} // inline std::map<HexRecordType, std::string> makeHexRecordTypeDescriptionMap()

inline const std::map<HexRecordType, std::string>& getHexRecordTypeDescriptionMap()
{
    static auto m = makeHexRecordTypeDescriptionMap();
    return m;
}




inline std::map<ParsingResult, std::string> makeParsingResultDescriptionMap()
{
std::map<ParsingResult, std::string> m =
{
{ ParsingResult::ok                          , "EOF record reached (not all data may be parsed)" },
{ ParsingResult::eof                         , "EOF record reached (not all data may be parsed)" },
{ ParsingResult::unexpectedEnd               , "End of data encountered, but no EOF record found" },
{ ParsingResult::unexpectedSpace             , "Unexpected space character encountered" },
{ ParsingResult::invalidRecord               , "The Record must begin with the 'colon' character" },
{ ParsingResult::unknownRecordType           , "Found a record with unknown type" },
{ ParsingResult::notDigit                    , "Non-xdigit character encountered" },
{ ParsingResult::brokenByte                  , "Bytes are represented eith pairs of hex digits. Appearance of a single digit mean that byte is broken" },
{ ParsingResult::tooManyDataBytes            , "Number of data bytes reached is greater than was stated at record start" },
{ ParsingResult::tooFewDataBytes             , "Number of data bytes reached is less than was stated at record start" },
{ ParsingResult::tooFewBytes                 , "Too few bytes in record" },
{ ParsingResult::checksumMismatch            , "Checksum mismatch" },
{ ParsingResult::dataSizeNotMatchRecordType  , "Number of data bytes in record does not match the record type" },
{ ParsingResult::invalidArgument             , "One, some, or all passed arguments are invalid" },
{ ParsingResult::mismatchAddressMode         , "Address mode mismatch to previously assigned address mode (mixed segment and linear address records)" },
{ ParsingResult::mismatchStartAddressMode    , "Start address mode mismatch to address mode (mixed segment and linear address records)" },
{ ParsingResult::multipleStartAddress        , "Start address already defined" },
{ ParsingResult::memoryOverlaps              , "Multiple records adress the same memory" }
};
return m;
} // inline std::map<ParsingResult, std::string> makeParsingResultDescriptionMap()

inline const std::map<ParsingResult, std::string>& getParsingResultDescriptionMap()
{
    static auto m = makeParsingResultDescriptionMap();
    return m;
}




inline std::map<AddressMode, std::string> makeAddressModeDescriptionMap()
{
std::map<AddressMode, std::string> m =
{
{ AddressMode::none                , "" },
{ AddressMode::undefined           , "" },
{ AddressMode::sba                 , "Segment Base Address" },
{ AddressMode::segmentBaseAddress  , "Segment Base Address" },
{ AddressMode::lba                 , "Linear Base Address" },
{ AddressMode::linearBaseAddress   , "Linear Base Address" }
};
return m;
} // inline std::map<AddressMode, std::string> makeAddressModeDescriptionMap()

inline const std::map<AddressMode, std::string>& getAddressModeDescriptionMap()
{
    static auto m = makeAddressModeDescriptionMap();
    return m;
}




inline std::map<ParsingOptions, std::string> makeParsingOptionsDescriptionMap()
{
std::map<ParsingOptions, std::string> m =
{
{ ParsingOptions::none           , "" },
{ ParsingOptions::allowComments  , "Allow comments (lines with '#' character first)" },
{ ParsingOptions::allowSpaces    , "Allow spaces in HEX lines" },
{ ParsingOptions::allowMultiHex  , "Normal HEX ends with EOF record. If we need read multiple HEXes from single text, we set this option" }
};
return m;
} // inline std::map<ParsingOptions, std::string> makeParsingOptionsDescriptionMap()

inline const std::map<ParsingOptions, std::string>& getParsingOptionsDescriptionMap()
{
    static auto m = makeParsingOptionsDescriptionMap();
    return m;
}




inline std::map<HexRecordsCheckCode, std::string> makeHexRecordsCheckCodeDescriptionMap()
{
std::map<HexRecordsCheckCode, std::string> m =
{
{ HexRecordsCheckCode::none                      , "" },
{ HexRecordsCheckCode::memoryOverlaps            , "Multiple records adress the same memory" },
{ HexRecordsCheckCode::mismatchAddressMode       , "Address mode mismatch to previously assigned address mode (mixed segment and linear address records)" },
{ HexRecordsCheckCode::mismatchStartAddressMode  , "Start address mode mismatch to address mode (mixed segment and linear address records)" }
};
return m;
} // inline std::map<HexRecordsCheckCode, std::string> makeHexRecordsCheckCodeDescriptionMap()

inline const std::map<HexRecordsCheckCode, std::string>& getHexRecordsCheckCodeDescriptionMap()
{
    static auto m = makeHexRecordsCheckCodeDescriptionMap();
    return m;
}



} // namespace hex
} // namespace marty

